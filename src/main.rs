use core::convert::TryInto;
use core::time::Duration;

use std::sync::{Arc, Mutex};

use log::info;

use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};
use embedded_svc::{
    http::{Headers, Method},
    io::{Read, Write},
};
use esp_idf_svc::hal::{delay::FreeRtos, peripherals::Peripherals};
use esp_idf_svc::http::server::EspHttpServer;
use esp_idf_svc::log::EspLogger;
use esp_idf_svc::timer::EspTaskTimerService;
use esp_idf_svc::wifi::{BlockingWifi, EspWifi};
use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition};
use rgb_led::{RGB8, WS2812RMT};
use serde::Deserialize;

use cgmlamp::dexcom::dexcom::Dexcom;

#[toml_cfg::toml_config]
pub struct Config {
    #[default(" ")]
    wifi_ssid: &'static str,
    #[default(" ")]
    wifi_pass: &'static str,
    #[default(" ")]
    dexcom_user: &'static str,
    #[default(" ")]
    dexcom_pass: &'static str,
}

static INDEX_HTML: &str = include_str!("index.html");

#[allow(dead_code)]
enum LedState {
    Steady(RGB8),
    Breathe(RGB8),
    Off,
}

enum AppState {
    Boot,
    ConnectWifi,
    GetSession,
    DisplayGlucose,
}

// Need lots of stack to parse JSON
const STACK_SIZE: usize = 10240;
// Max payload length
const MAX_LEN: usize = 128;

const BRIGHTNESS: u8 = 128;

const RED: RGB8 = RGB8 {
    r: BRIGHTNESS,
    g: 0,
    b: 0,
};
const BLUE: RGB8 = RGB8 {
    r: 0,
    g: 0,
    b: BRIGHTNESS,
};
const YELLOW: RGB8 = RGB8 {
    r: BRIGHTNESS,
    g: BRIGHTNESS,
    b: 0,
};
const BLACK: RGB8 = RGB8 { r: 0, g: 0, b: 0 };
const WHITE: RGB8 = RGB8 {
    r: BRIGHTNESS,
    g: BRIGHTNESS,
    b: BRIGHTNESS,
};

const GREEN: RGB8 = RGB8 {
    r: 0,
    g: BRIGHTNESS,
    b: 0,
};

const PURPLE: RGB8 = RGB8 {
    r: BRIGHTNESS,
    g: 0,
    b: BRIGHTNESS,
};

#[derive(Deserialize)]
struct FormData<'a> {
    first_name: &'a str,
    age: u32,
    birthplace: &'a str,
}

// red -> green
// green -> blue
// blue -> purple

fn main() -> anyhow::Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    EspLogger::initialize_default();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Setup ESP-type stuff
    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    // Application state

    // Shared state between LED-writing thread and main thread
    let lock = Arc::new(Mutex::new(LedState::Off));

    // App state
    let mut app_state = AppState::Boot;

    // Create dexcom object
    let mut dexcom = Dexcom::new();

    // Monitor glucose
    let mut no_measurement_count = 0;

    // LED-writing thread
    let timer_service = EspTaskTimerService::new()?;
    let callback_timer = {
        // Set up LED
        let led = peripherals.pins.gpio8;
        let channel = peripherals.rmt.channel0;
        let mut ws2812 = WS2812RMT::new(led, channel)?;
        let lock = Arc::clone(&lock);

        timer_service.timer(move || {
            let led = lock.lock().unwrap();
            match *led {
                LedState::Steady(color) => ws2812.set_pixel(color).unwrap(),
                LedState::Breathe(color) => {
                    for i in 0..80 {
                        ws2812
                            .set_pixel(get_color_in_sweep(&color, &BLACK, 80, i))
                            .unwrap();
                        FreeRtos::delay_ms(10);
                    }
                    for i in 0..80 {
                        ws2812
                            .set_pixel(get_color_in_sweep(&BLACK, &color, 80, i))
                            .unwrap();
                        FreeRtos::delay_ms(10);
                    }
                }
                LedState::Off => ws2812.set_pixel(BLACK).unwrap(),
            };
        })?
    };
    callback_timer.every(Duration::from_secs(2))?;

    let mut wifi = BlockingWifi::wrap(
        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?,
        sys_loop,
    )?;

    loop {
        match app_state {
            AppState::Boot => {
                // Update presentation
                let mut led = lock.lock().unwrap();
                *led = LedState::Breathe(WHITE);

                // Advance to next state
                app_state = AppState::ConnectWifi;
            }
            AppState::ConnectWifi => {
                // Set up wifi, connect to AP
                connect_wifi(&mut wifi, app_config.wifi_ssid, app_config.wifi_pass)?;

                let mut server = create_server()?;

                server.fn_handler("/", Method::Get, |req| {
                    req.into_ok_response()?
                        .write_all(INDEX_HTML.as_bytes())
                        .map(|_| ())
                })?;

                server.fn_handler::<anyhow::Error, _>("/post", Method::Post, |mut req| {
                    let len = req.content_len().unwrap_or(0) as usize;

                    if len > MAX_LEN {
                        req.into_status_response(413)?
                            .write_all("Request too big".as_bytes())?;
                        return Ok(());
                    }

                    let mut buf = vec![0; len];
                    req.read_exact(&mut buf)?;
                    let mut resp = req.into_ok_response()?;

                    if let Ok(form) = serde_json::from_slice::<FormData>(&buf) {
                        write!(
                            resp,
                            "Hello, {}-year-old {} from {}!",
                            form.age, form.first_name, form.birthplace
                        )?;
                    } else {
                        resp.write_all("JSON error".as_bytes())?;
                    }

                    Ok(())
                })?;
                core::mem::forget(server);

                // Advance to next state
                app_state = AppState::GetSession;
            }
            AppState::GetSession => {
                dexcom
                    .connect(app_config.dexcom_user, app_config.dexcom_pass)
                    .unwrap();

                app_state = AppState::DisplayGlucose;
            }
            AppState::DisplayGlucose => {
                // Update last
                no_measurement_count += 1;

                // Are we still connected to wifi? If not, sending a request will crash the program
                if !wifi.is_connected().unwrap() {
                    info!("Not connected to wifi, reconnecting");
                    app_state = AppState::ConnectWifi;
                } else {
                    // Get new reading
                    if let Ok(measurement) = dexcom.get_latest_glucose() {
                        info!("{:?}", measurement);

                        let color = glucose_to_ledstate(measurement.value);
                        let mut led = lock.lock().unwrap();
                        *led = color;
                        no_measurement_count = 0;
                    } else if no_measurement_count >= 600 {
                        let mut led = lock.lock().unwrap();
                        *led = LedState::Breathe(YELLOW);
                    }

                    // Do it once every 20 sec. Any slower and the modem will go to sleep.
                    FreeRtos::delay_ms(1000 * 20);
                }
            }
        };
    }
}

fn get_color_in_sweep(start_color: &RGB8, end_color: &RGB8, total: usize, idx: isize) -> RGB8 {
    let r_step = (end_color.r as f64 - start_color.r as f64) / (total as f64);
    let g_step = (end_color.g as f64 - start_color.g as f64) / (total as f64);
    let b_step = (end_color.b as f64 - start_color.b as f64) / (total as f64);

    RGB8::new(
        ((start_color.r as f64) + (idx as f64 * r_step)) as u8,
        ((start_color.g as f64) + (idx as f64 * g_step)) as u8,
        ((start_color.b as f64) + (idx as f64 * b_step)) as u8,
    )
}

fn glucose_to_ledstate(value: isize) -> LedState {
    // Multi-colored colormap
    // Red -> Green -> Blue -> Purple
    match value {
        0..55 => LedState::Breathe(RED),
        55..152 => LedState::Steady(get_color_in_sweep(&RED, &GREEN, 152 - 55, value - 55)),
        152..250 => LedState::Steady(get_color_in_sweep(&GREEN, &BLUE, 250 - 152, value - 152)),
        250..300 => LedState::Steady(get_color_in_sweep(&BLUE, &PURPLE, 300 - 250, value - 250)),
        300..500 => LedState::Breathe(PURPLE),
        _ => LedState::Breathe(WHITE),
    }
}

fn connect_wifi(
    wifi: &mut BlockingWifi<EspWifi<'static>>,
    ssid: &str,
    pass: &str,
) -> anyhow::Result<()> {
    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: ssid.try_into().unwrap(),
        bssid: None,
        auth_method: AuthMethod::WPA2Personal,
        password: pass.try_into().unwrap(),
        channel: None,
        ..Default::default()
    });

    wifi.set_configuration(&wifi_configuration)?;

    wifi.start()?;
    info!("Wifi started, connecting to {}", ssid);

    loop {
        match wifi.connect() {
            Ok(_) => break,
            Err(e) => {
                info!("Error connecting to WIFI: ({}). retrying", e.to_string());
                continue;
            }
        };
    }
    info!("Wifi connected");

    wifi.wait_netif_up()?;
    info!("Wifi netif up");

    Ok(())
}

fn create_server() -> anyhow::Result<EspHttpServer<'static>> {
    let server_configuration = esp_idf_svc::http::server::Configuration {
        stack_size: STACK_SIZE,
        ..Default::default()
    };

    Ok(EspHttpServer::new(&server_configuration)?)
}
