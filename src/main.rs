use core::convert::TryInto;
use core::time::Duration;

use std::sync::{Arc, Mutex};

use log::info;

use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};

use esp_idf_svc::hal::{delay::FreeRtos, peripherals::Peripherals};
use esp_idf_svc::log::EspLogger;
use esp_idf_svc::wifi::{BlockingWifi, EspWifi};
use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition};
use esp_idf_svc::timer::EspTaskTimerService;

use rgb_led::{RGB8, WS2812RMT};

use cgmlamp::dexcom::dexcom::Dexcom;
use cgmlamp::dexcom::dexcom::GlucoseReading;

#[toml_cfg::toml_config]
pub struct Config {
    #[default(" ")]
    wifi_ssid: &'static str,
    #[default(" ")]
    wifi_pass: &'static str,
    #[default(" ")]
    dexcom_user: &'static str,
    #[default(" ")]
    dexcom_pass: &'static str,
}

enum LedState {
    Steady(RGB8),
    Breathe(RGB8),
}

fn main() -> anyhow::Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    EspLogger::initialize_default();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Setup ESP-type stuff
    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    // Shared state between LED-writing thread and main thread
    let lock = Arc::new(Mutex::new(GlucoseReading::new()));
    let led_lock = Arc::new(Mutex::new(LedState::Breathe(RGB8::new(128, 128, 128))));

    // LED-writing thread
    let timer_service = EspTaskTimerService::new()?;
    let callback_timer = {
        // Set up LED
        let led = peripherals.pins.gpio8;
        let channel = peripherals.rmt.channel0;
        let mut ws2812 = WS2812RMT::new(led, channel)?;
        let lock = Arc::clone(&lock);
        let led_lock = Arc::clone(&led_lock);

        timer_service.timer(move || {
            // TODO: State machine here
            // Quick LED flicker to show new value
            //let color = RGB8::new(128, 128, 128);
            //ws2812.set_pixel(color).unwrap();
            //FreeRtos::delay_ms(100);

            // Set color by glucose value
            //let measurement = lock.lock().unwrap();
            let led = led_lock.lock().unwrap();
            match *led {
                LedState::Steady(color) => ws2812.set_pixel(color).unwrap(),
                LedState::Breathe(color) => ws2812.set_pixel(color).unwrap(),
            };
            FreeRtos::delay_ms(900);
        })?
    };
    callback_timer.every(Duration::from_secs(1))?;

    // Set up wifi, connect to AP
    let mut wifi = BlockingWifi::wrap(
        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?,
        sys_loop,
    )?;
    connect_wifi(&mut wifi, app_config.wifi_ssid, app_config.wifi_pass)?;

    // Get user id
    let mut dexcom = Dexcom::new();
    let user_id = dexcom
        .get_user_id(app_config.dexcom_user, app_config.dexcom_pass)
        .unwrap();
    info!("user id: {}", user_id);

    // Login
    let session = dexcom
        .get_session(&user_id, app_config.dexcom_pass)
        .unwrap();
    info!("session: {}", session);

    // Monitor glucose
    loop {
        // Get new reading 
        let readings = dexcom.get_glucose(&session, 5, 1).unwrap();
        if readings.len() > 0 {
            //let mut measurement = lock.lock().unwrap();
            let measurement = readings[0];
            info!("{:?}", measurement);
            let color = glucose_to_ledstate(measurement.value);
            let mut led = led_lock.lock().unwrap();
            *led = color;
        }

        // Do it once every 20 sec. Any slower and the modem will go to sleep.
        FreeRtos::delay_ms(1000 * 20);
    }
}

fn glucose_to_ledstate(value: isize) -> LedState {
    match value {
        0..55 => LedState::Breathe(RGB8::new(255, 0, 0)),
        55..250 => {
            let r = (255f64 - (255f64 * (value - 46) as f64) / ((235 - 46) as f64)) as u8;
            let g = 0;
            let b = ((255f64 * (value - 46) as f64) / ((235 - 46) as f64)) as u8;
            LedState::Steady(RGB8::new(r, g, b))
        }
        250..300 => LedState::Steady(RGB8::new(0, 0, 255)),
        300..500 => LedState::Breathe(RGB8::new(0, 0, 255)),
        _ => LedState::Breathe(RGB8::new(128, 128, 128)),
    }
}

fn connect_wifi(
    wifi: &mut BlockingWifi<EspWifi<'static>>,
    ssid: &str,
    pass: &str,
) -> anyhow::Result<()> {
    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: ssid.try_into().unwrap(),
        bssid: None,
        auth_method: AuthMethod::WPA2Personal,
        password: pass.try_into().unwrap(),
        channel: None,
        ..Default::default()
    });

    wifi.set_configuration(&wifi_configuration)?;

    wifi.start()?;
    info!("Wifi started, connecting to {}", ssid);

    loop {
        match wifi.connect() {
            Ok(_) => break,
            Err(e) => {
                info!("Error connecting to WIFI: ({}). retrying", e.to_string());
                continue;
            }
        };
    }
    info!("Wifi connected");

    wifi.wait_netif_up()?;
    info!("Wifi netif up");

    Ok(())
}
