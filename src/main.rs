use core::convert::TryInto;
use log::info;

use embedded_svc::wifi::{AuthMethod, ClientConfiguration, Configuration};

use esp_idf_svc::hal::{delay::FreeRtos, peripherals::Peripherals};
use esp_idf_svc::log::EspLogger;
use esp_idf_svc::wifi::{BlockingWifi, EspWifi};
use esp_idf_svc::{eventloop::EspSystemEventLoop, nvs::EspDefaultNvsPartition};

use rgb_led::{RGB8, WS2812RMT};

use cgmlamp::dexcom::dexcom::{Dexcom, DexcomGlucoseReading};

#[toml_cfg::toml_config]
pub struct Config {
    #[default(" ")]
    wifi_ssid: &'static str,
    #[default(" ")]
    wifi_pass: &'static str,
    #[default(" ")]
    dexcom_user: &'static str,
    #[default(" ")]
    dexcom_pass: &'static str,
}

fn main() -> anyhow::Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    EspLogger::initialize_default();

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;

    // Setup Wifi
    let peripherals = Peripherals::take()?;
    let sys_loop = EspSystemEventLoop::take()?;
    let nvs = EspDefaultNvsPartition::take()?;

    let led = peripherals.pins.gpio8;
    let channel = peripherals.rmt.channel0;
    let mut ws2812 = WS2812RMT::new(led, channel)?;

    ws2812.set_pixel(RGB8::new(0, 0, 0))?;

    let mut wifi = BlockingWifi::wrap(
        EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?,
        sys_loop,
    )?;

    connect_wifi(&mut wifi, app_config.wifi_ssid, app_config.wifi_pass)?;

    // Get user id
    let mut dexcom = Dexcom::new();
    let user_id = dexcom
        .get_user_id(app_config.dexcom_user, app_config.dexcom_pass)
        .unwrap();
    info!("user id: {}", user_id);

    // Login
    let session = dexcom
        .get_session(&user_id, app_config.dexcom_pass)
        .unwrap();
    info!("session: {}", session);

    // Monitor glucose
    loop {
        let glucose_readings = dexcom.get_glucose(&session, 5, 1).unwrap();
        for glucose in &glucose_readings {
            info!("glucose: {} and {}", glucose.Value, glucose.Trend);
        }

        if glucose_readings.len() > 0 {
            let last_value = glucose_readings[0].Value;

            // Turn white for a bit just to signify a new sample
            let color = RGB8::new(128, 128, 128);
            ws2812.set_pixel(color)?;
            FreeRtos::delay_ms(100);

            // Set color by glucose value
            let color = match last_value {
                0..55 => RGB8::new(255, 0, 0), // TODO: throb
                55..250 => {
                    let r =
                        (255f64 - (255f64 * (last_value - 46) as f64) / ((235 - 46) as f64)) as u8;
                    let g = 0;
                    let b = ((255f64 * (last_value - 46) as f64) / ((235 - 46) as f64)) as u8;
                    RGB8::new(r, g, b)
                }
                250..300 => RGB8::new(0, 0, 255),
                300..500 => RGB8::new(0, 0, 255), // TODO: throb
                _ => RGB8::new(128, 128, 128),    // TODO: throb
            };
            ws2812.set_pixel(color)?;
        }
        FreeRtos::delay_ms(1000 * 20);
    }

    Ok(())
}

fn connect_wifi(
    wifi: &mut BlockingWifi<EspWifi<'static>>,
    ssid: &str,
    pass: &str,
) -> anyhow::Result<()> {
    let wifi_configuration: Configuration = Configuration::Client(ClientConfiguration {
        ssid: ssid.try_into().unwrap(),
        bssid: None,
        auth_method: AuthMethod::WPA2Personal,
        password: pass.try_into().unwrap(),
        channel: None,
        ..Default::default()
    });

    wifi.set_configuration(&wifi_configuration)?;

    wifi.start()?;
    info!("Wifi started");

    loop {
        match wifi.connect() {
            Ok(_) => break,
            Err(e) => {
                info!("Error connecting to WIFI: ({}). retrying", e.to_string());
                continue;
            }
        };
    }
    info!("Wifi connected");

    wifi.wait_netif_up()?;
    info!("Wifi netif up");

    Ok(())
}
